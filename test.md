# ECMAScript 6 简介
>ECMAScript 6.0(以下简称ES6)是JavaScript语言的下一代标准，已经在2015年6月正式发布了，它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业及开发语言。
## 1.ECMAScript和javaScript的关系
>一个常见的问题是，ECMAScirpt和javaScript到底是什么关系？

>要讲清楚这个问题，需要回顾历史，1996年11月，javaScript的创造者Netscape公司，决定将javaScript提交个标准化组织ECMA，希望这种语言能够成为国际标准，次年ECMA发布262号标准文件（ECMA-262)的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版，该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一个是商标，Java和Sun公司的商标，根据授权协议，只有Netscape公司可以合法使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想要体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。

>因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现(另外的ECMAScript方言还有JScript和ActionScript)。日常场合，这两个词是可以互换得到。

## 2.ES6和ECMAScript 2015的关系

> ECMAScript 2015 （简称ES2015)这个词，也是经常可以看到的，它与ES6是什么关系呢？

> 2011年,ECMAScript5.1版本发布后，就开始制定6.0版了，因此，ES6这个词的愿意，就是值JavaScript语言的下一个版本。

> 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。
常规的做法是先发布6.0版，过一段时间再发6.1版，然后6.2版，6.3版等等。

>但是标准的制定者不想这样做。他们想让标准的升级成为常规流程： 任何热在任何时候，都可以向标准委员会提交新语法的天，然后标准委员会每个月开一次会，
评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。

>标准委员会最终决定，标准在每年的6月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的6月份，草案就自然变成了新一年的版本。
这样一来，就不需要以前的版本号了，只要用年份标记就可以了。

>ES6的第一个版本，就这样在2015年6月发布了，正式名称就是（ECMAScript 2015标准）（简称ES2015)。2016年6月，小幅修订的(ECMAScirpt 2016标准)。根据计划，2017年6月发布ES2017标准。

>因此，ES6即使一个历史名词，也是一个泛指，含义是5.1版本以后的JavaScrit的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式的名称。
特指该年发布的正式版本的语言标准，本书中提到ES6的地方，一般是指ES2015标准，但有时也是泛指**下一代JavaScript语言**

## 3.语法提案的批准流程

>任何人都可以向标准委员会（又成TC39委员会）提案，要求修改语言标准。

>一种新的语法从提案到变成正确标准，需要经过五个阶段，每个阶段的变动都需要由TC39委员会批准。
* Stage 0 - strawman(展示阶段)
* Stage 1 - Proposal(征求意见阶段)
* Stage 2 - Draft(草案阶段)
* Stage 3 - Candidate(候选人阶段)
* Stage 4 - Finished(定案阶段)
>一个提案只要能进入Stage 2，就差不多肯定会包括在以后的正式标准里面。
>ECMAScript当前的所有提案，可以在TC39的官方网站GitHub.com/tc39/ecma262查看。
>本练习介绍5.1版本以后所有的新语法。对于那些明确或很有希望，将列入标准的新语法，都将予以介绍。

>目前各大浏览器ES6的支持可以查看[es6兼容](kangax.github.io/compat-table/es6/).

>Node.js是JavaScript的服务器运行环境（runtime)。它对ES6的支持最高，除了那些默认打开的功能。

## let 和 const命令

### 1.let命令

#### 基本用法

>ES6新增了let命令，用来声明变量，它的用法类似于var，但是所声明的变量，只在let命令所
>在的代码块内有效。

    {
        let a = 10;
        var b = 1;
    }
    console.log(a);
    console.log(b);
>上面代码在代码块中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量。
>结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它
>所在的代码块有效

    for循环计数器，就很合适使用let命令
    for (let i = 0; i < 10; i++) {
           
    }
    console.log(i);
>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。
>下面的代码如果使用var,最后输出的时10

      var a =[];
       for (var i = 0; i < 10; i++) {
           a[i] = function (){
               console.log(i);
           }
       }
       a[6]();
>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。
>每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i),
>里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，
>导致运行时输出的最后一轮的i的值，也就是10。

>如果使用let，声明的变量仅在块级作用域内有效，最后输出的时6

      var a =[];
       for (let i = 0; i < 10; i++) {
           a[i] = function (){
               console.log(i);
           }
       }
       a[6]();
>上面代码中，变量i是let声明的，当时的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，
>所以最后输出的时6，你可能会稳，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出
>本轮循环的值？这是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮得到变量i时，就在上一轮
>循环的基础上进行计算。

>另外，for循环还有一个特别之处，就是设置循环变量的那部份是一个父作用域，而循环体内是一个单独的子作用域。

#### 不存在变量提升

>var 命令会发生"变量提升"现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少
>是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。

>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

    console.log(foo);
    var foo = 2;
    console.log(bar);
    let bar = 2;
>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是
>没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升，这个表示在声明它之前，变量
>bar是不存在的，这时如果用到它，就会抛出一个错误。

#### 暂时性死区

>只有块状作用域内存在let命令，它所声明的变量就"绑定"这个区域，不再受外部的影响。

    var tmp = 123;

    if(true){
        tmp = "abc";
        let tmp;
    }

>上面代码中，存在全局变量tmp,但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个
>块级作用域，所以在let声明变量前，对tmp赋值会报错。

>es6明确规定，如果区块中存在let和const命令，这个区块对这个鞋命令声明的变量，从一开始就形成了
>封闭作用域，凡是在声明之前就使用这些变量，就会报错。

>总之，在代码块内，使用let命令声明变量之前，改变量都是不可用的，这在语法上，称为“暂时性死区”
>(temporal dead zone 简称 TDZ)

>上面代码中，在let命令声明变量tmp之前，都属于tmp的"死区"。
>“暂时性死去”也意味着typeof不再是一个百分之百安全的操作。

    typeof x;
    let x;
>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的死区，只要用到该变量就会报错。
>因此,typeof运行时就会抛出一个ReferenceError。

>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错

    console.log(typeof x);
>上面代码中，x是一个不存在的变量名，结果返回“undefined"。所以，在没有let之前，
>typeof运算符是百分之百安全的，永远不会报错，现在这一点不成立了。这样的设计是为了让大家养成
>良好的编程习惯，变量一定要在声明之后使用，否则就报错。

>有些死区比较隐蔽，不太容易发现。

    function bar(x=y,y=2){
        return [x,y]
    }
    bar();
>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y
>而此时y还没有声明，属于"死区"。如果y的默认值是x，就不会报错,因为此时x已经声明了。
    
    function bar(x=2,y=x){
        return [x,y];
    }
    bar();
>另外，下面的代码也会报错，与let的行为不同。

    let x = x;
>上面代码报错，也是因为暂时性死去，使用let声明变量时，只要变量在还没有声明完成前使用，
>就会报错。上面这行属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错。

#### 不允许重复声明

>let 不允许在相同作用域内，重复声明同一个变量。
    
    function func(){
           let a = 10;
           var a = 1;
       }
>因此，不能再函数内部重复声明参数

    function func(arg){
          let arg;
    }//报错
     function func(arg) {
            {
                let arg;
            }
    }//不报错
### 2.块级作用域
#### 为什么需要块级作用域？
>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
>第一个场景内层变量可能会覆盖外层变量。

     var tmp = new Date();
        function f(){
            console.log(tmp);
            if(false){
                var tmp = "hello world"
            }
        }
        f();
>上面代码的愿意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量，但是
>函数f执行后，输出结果为undefined，愿意在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。

>第二个场景，用来计数的循环变量泄露为全局变量。

    var s = "hello";
    for(var i = 0; i < s.length; i++){
        console.log(s[i]);
    }
    console.log(i);
>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。
#### ES6的块级作用域
>let实际上为JavaScript新增了块级作用域。

        function f1(){
            let n = 5;
            if(true){
                let n = 10;
            }
            console.log(n);
        }
        f1();
>上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。
>如果两次都使用var定义变量n，最后输的值为10。

>ES6允许块级作用域的任意嵌套

    


    
    

    

